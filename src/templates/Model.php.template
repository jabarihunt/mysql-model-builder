<?php namespace [NAMESPACE]\Models\Base;

    use jabarihunt\MySQL as DB;

    /********************************************************************************
     * MODEL CLASS
     * This is the model that all other base models (generated) extend.
     * @author Jabari J. Hunt <jabari@jabari.net>
     ********************************************************************************/

        class Model {

            /********************************************************************************
             * CONSTRUCT METHOD
             *
             * The model constructors should be private.  It should only be called by
             * internal static methods (create, get, etc) to create new model instances.
             *
             * @param mixed $data An array values used to create the model
             ********************************************************************************/

                protected function __construct(array $data) {

                    // ADD DATA TO MODEL IF THE DATA FIELD ALREADY EXISTS

                        foreach ($data as $field => $value) {
                            if (property_exists($this, $field)) {$this->$field = $value;}
                        }

                }

            /********************************************************************************
             * UPDATE METHOD
             *
             * Used by all child models to update their respective table(s). If any values
             * need to be altered first, simply override this method, edit the values as
             * needed, then call `parent::update($values)` at the end of the method.
             *
             * @param mixed $data An array of values to update
             * @return boolean
             ********************************************************************************/

                public function update(array $data): bool {

                    // RUN BEFORE UPDATE CALLBACK

                        $data = call_user_func([$this, 'beforeUpdate'], $data);

                    // SET INITIAL VARIABLES

                        $bindTypes = '';
                        $set       = '';
                        $updated   = FALSE;

                    // LOOP THROUGH VALUES -> SANITIZE, ADD TO UPDATE QUERY PARTS

                        foreach ($data as $field => $value) {

                            $data[$field] = DB::sanitize($value, static::DATA_TYPES[$field]);
                            $data[$field] = &$data[$field];    // ADDED TO SATISFY THE call_user_func_array() METHOD
                            $set         .= "`{$field}` = ?, ";

                            if (in_array(static::DATA_TYPES[$field], DB::DATA_TYPE_INTEGER)) {
                                $bindTypes .= 'i';
                            } else if (in_array(static::DATA_TYPES[$field], DB::DATA_TYPE_REAL)) {
                                $bindTypes .= 'd';
                            } else {
                                $bindTypes .= 's';
                            }

                        }

                        $set = rtrim($set, ', ');

                    // CREATE & RUN PREPARED STATEMENT QUERY -> PROCESS RESULTS

                        $result = DB::prepare(
                            "UPDATE `" . static::TABLE_NAME . "` SET {$set} WHERE `id` = '{$this->id}'",
                            $data,
                            $bindTypes
                        );

                        if (is_int($result) && $result > 0) {

                            foreach ($data as $field => $value) {
                                $this->$field = $value;
                            }

                            $updated = TRUE;

                        }

                    // RUN AFTER UPDATE CALLBACK | CLOSE STATEMENT

                        if ($updated) {
                            call_user_func([$this, 'afterUpdate']);
                        }

                        return $updated;

                }

            /********************************************************************************
             * DELETE METHOD
             * @returns boolean
             ********************************************************************************/

                public function delete(): bool {

                    call_user_func([$this, 'beforeDelete']);
                    $deleted = self::deleteByIds([$this->id]);
                    call_user_func([$this, 'afterDelete']);
                    return $deleted;

                }

            /********************************************************************************
             * DELETE BY IDS METHOD
             * @param array $ids
             * @return boolean
             ********************************************************************************/

                public static function deleteByIds(array $ids): bool {

                    // SET INITIAL VARIABLES | DELETE FROM THE DATABASE | RETURN BOOLEAN RESULT

                        $ids      = self::sanitize($ids, DB::DATA_TYPE_INTEGER);
                        $idString = implode(',', $ids);

                        if (!empty($idString)) {
                            $result = DB::query("DELETE FROM `" . static::TABLE_NAME . "` WHERE `id` IN ({$idString})");
                        }

                        return (
                            !empty($result) &&
                            is_int($result) &&
                            $result > 0
                        );

                }

            /********************************************************************************
             * CALLBACK METHODS
             *
             * The model constructors should be private.  It should only be called by
             * internal static methods (create, get, etc) to create new model instances.
             ********************************************************************************/

                protected static function beforeCreate(array $data): array {return $data;}
                protected function afterCreate() {}
                protected static function beforeGet($idOrData) {return $idOrData;}
                protected function afterGet() {}
                protected function beforeUpdate(array $data): array {return $data;}
                protected function afterUpdate() {}
                protected function beforeDelete() {}
                protected function afterDelete() {}

            /********************************************************************************
             * SANITIZE METHOD
             *
             * Sanitize an array of passed values.  Uses the DB::sanitizeValue() method;
             *
             * @param array $data An array values to update
             * @return array
             ********************************************************************************/

                final protected static function sanitize(array $data): array {

                    // SET THE FIELD DATA TYPE | SANITIZE FIELD | RETURN DATA

                        foreach ($data as $field => $value) {
                            $dataType     = (is_string($field) && !empty(static::DATA_TYPES[$field])) ? static::DATA_TYPES[$field] : NULL;
                            $data[$field] = DB::sanitize($value, $dataType);
                        }

                        return $data;

                }

        }

?>